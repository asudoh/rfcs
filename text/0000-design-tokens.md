- Start Date: 2018-02-26
- RFC PR:
- Carbon Issue: https://github.com/carbon-design-system/carbon-themes/pull/27#issue-169200892

# Summary

Introduce "design tokens", variables that can be shared among different types of our source code, e.g. `.scss`, `.js` and HTML templats.

# Basic example

## Design tokens reused for other design tokens (aliases)

e.g. Brand prefix:

```yaml
aliases:
  prefix: "bx"
```

e.g. Theming:

```yaml
imports:
  - ./colors.yml
props:
  brand-01: "{!color__blue-51}"
  …
```

e.g. Component name, combined with brand prefix (via `imports`):

```yaml
imports:
  - ../../globals/tokens/brand.yml
aliases:
  name: "accordion"
```

## Design token files for components

e.g. CSS classes:

```yaml
imports:
  - ./_accordion.yml
namespaces:
  - "{!name}"
  - "class"
props:
  base: "{!prefix}--{!name}"
  item: "{!prefix}--{!name}__item"
  item-active: "{!prefix}--{!name}__item--active"
  …
```

e.g. CSS selectors:

```yaml
imports:
  - ./_accordion.yml
  - ./accordion--classes.yml
namespaces:
  - "{!name}"
  - "selector"
props:
  init: "[data-{!name}]"
  item: ".{!item:class}"
  …
```

e.g. Vanilla component options:

```yaml
imports:
  - ./accordion--classes.yml
  - ./accordion--selectors.yml
namespaces:
  - "{!name}"
  - "setting"
props:
  selectorInit: "{!init:selector}"
  selectorAccordionItem: "{!item:selector}"
  …
  classActive: "{!item-active:class}"
```

## Design token output

e.g. `.scss` variables:

```scss
$accordion-class-base: "bx--accordion"
$accordion-class-item: "bx--accordion__item"
$accordion-class-item-active: "bx--accordion__item--active"
…
```

e.g. Vanilla component options:

```json
{
  "selectorInit": "[data-accordion]",
  "selectorAccordionItem": ".bx--accordion__item",
  …
  "classActive": "bx--accordion__item--active"
}
```

e.g. CSS classes list that React components can refer to:

```json
{
  "base": "bx--accordion",
  "item": "bx--accordion__item",
  "item-active": "bx--accordion__item--active",
  …
}
```

## Using design tokens

e.g. in component `.scss`:

```scss
// Generated by build process from design tokens
@import 'scss/components/accordion/accordion--classes';

@include exports('accordion') {
  .#{$accordion-class-base} {
    color: $ui-01;
    …
  }
  …
}
```

e.g. in vanilla component `.js`:

```javascript
// Generated by build process from design tokens
import defaultOptions from '../../../tokens/accordion/accordion.json';

…

class Accordion extends mixin(…) {
  …

  _toggle(element) {
    …

    element.classList.toggle(this.options.classActive);
  }

  static options = defaultOptions;

  …
}
```

e.g. in React component `.js`:

```javascript
import React, { Component } from 'react';
// Generated by build process from design tokens
import cssClasses from 'carbon-components/tokens/accordion/accordion--classes.json';

…

class Accordion extends Component {
  render() {
    …

    const { 'item-active': classItemActive, classItem } = cssClasses;
    const classNames = classnames(
      {
        classItemActive: this.state.open,
      },
      classItem,
      className
    );
    
    …
  }
}
```

# Motivation

The biggest motivation is for [brand prefixing](https://github.com/carbon-design-system/carbon-components/pull/492) support in our [`carbon-components-react`](https://github.com/carbon-design-system/carbon-components-react) codebase. Unlike our [vanilla](https://github.com/carbon-design-system/carbon-components) codebase, `carbon-components-react` hard-codes all CSS classes, which makes us require one-step abstraction (making them variables) for brand prefixing support.

The design token notion takes another step of the abstraction, making brand prefix, etc. variables reusable across different types of artifacts in our codebase, especially our `.scss`, `.js` and HTML template files.

# Detailed design

## Design token file format

The design tokens file are written in YAML, which has the following top-level properties:

* [`aliases`](#aliases)
* [`props`](#props)
* `namespaces`
* [`includes`](#imports-and-includes)
* [`imports`](#imports-and-includes)

### `aliases`

`aliases` allow you to define design tokens referred by other aliases, design tokens and namespaces.
In below example, the `base` property will be `bx--accordion`:

```yaml
aliases:
  prefix: "bx"
props:
  base: "{!prefix}--accordion"
```

This document refers to `{!aliasname}` as *alias resolution notation*:

#### Referring to aliases with specific namespaces

You can refer to an alias with a specific namespaces. If there are two design token files with different `namespaces` specified:

```yaml
namespaces:
  - "foo"
  - "bar"
aliases:
  prefix: "bx"
```

```yaml
namespaces:
  - "baz"
  - "qux"
aliases:
  prefix: "bx"
```

You can refer to the the the former `prefix` alias with `{!prefix:bar:foo}` notation and the latter `prefix` alias with `{!prefix:qux:baz}` notation, even if both design token files above are imported.

**Note**: The namespaces work as the suffixes in alias reference notations. Therefore, the order of namespaces in alias reference notations (e.g. `bar` then `foo`) are the reverse of the order of `namespaces` definitions (e.g. `foo` then `bar`).

You can even do `{!prefix:bar}` (omitting `foo`) or `{!prefix:qux}` (omitting `baz`) as long as the alias can be uniquely resolved.

### `props`

`props` defines the design tokens that are emitted as design token output:

```yaml
aliases:
  prefix: "bx"
props:
  base: "{!prefix}--accordion"
```

For example, above design token file may emit the following:

```scss
$base: bx--accordion`;
```

```json
{
  "base": "bx--accordion",
}
```

#### Applying namespaces to `props`

If `namespaces` is used along with `props`, the namespaces are applied to the design token output. For example, if the last example of design token file has `foo` and `bar` namespaces, the design token output will be like:

```scss
$foo-bar-base: bx--accordion`;
```

```json
{
  "foo": {
    "bar": {
      "base": "bx--accordion",
    }
  }
}
```

### `imports` and `includes`

`imports` allows a design token file to refer to another design token file.
In below example, if the former design token file below is named `brand.yml` and put in the same directory as the latter design token file, the `base` property in the latter token file will be `bx--accordion`:

```yaml
aliases:
  prefix: "bx"
```

```yaml
imports:
  - ./brand.yml
props:
  base: "{!prefix}--accordion"
```

`includes` is similar, but different from `imports` if the imported design token files has `props`. For example, if `prefix` in above example is defined as a design token (`props` instead of `alias`), `includes` puts `prefix` in the design token output in addition to `base`, whereas `imports` does not. In other words, `imports` treats `props` in the imported file as `aliases` (instead of keeping them as `props`).

## Types of design tokens

This spec defines several different categories of design tokens:

* [Global aliases](#global-aliases): Define anything that are shared among multiple tokens files
* [Global tokens](#global-tokens): Used primary for global theming
* [Component aliases](#component-aliases): Define things that are shared among multiple token files for the component
* [Component class tokens](#component-class-tokens): Allows us to reuse CSS class names among `.scss`, `.js` and HTML template files
* [Component selector tokens](#component-selector-tokens): Primary for our vanilla codebase, abstracting different DOM structure from different HTML templates for themes
* [Component setting tokens](#component-setting-tokens): Primary for our vanilla codebase, with the same content as components' static `options` property seen in Carbon `8.x`

Carbon Design System implementation may add other types of design tokens as needed.

### Global aliases

Global aliases define anything that are shared among multiple tokens files, e.g. brand prefix:

```yaml
aliases:
  prefix: "bx"
```

### Global tokens

Global tokens are used primary for theming:

```yaml
imports:
  - ./colors.yml
props:
  brand-01: "{!color__blue-51}"
  brand-02: "{!color__blue-40}"
  brand-03: "{!color__teal-20}"
  …
```

Given `carbon-components/src/globals/tokens/color-theme.yaml` as the file name for above, the build toolchain generates `carbon-components/scss/globals/tokens/color-theme.scss`, like below, replacing the corresponding ones in Carbon [`_vars.scss`](https://github.com/carbon-design-system/carbon-components/blob/db4e058/src/globals/scss/_vars.scss#L23-L48):

```scss
$brand-01: rgb(61, 112, 178) !default;
$brand-02: rgb(85, 150, 230) !default;
$brand-03: rgb(110, 237, 216) !default;
…
```

Such generated `.scss`, as the path indicates, will be included in `carbon-components` NPM package.

### Component aliases

Component aliases define things that are shared among multiple token files for the component, e.g. component name:

```yaml
imports:
  - ../../globals/tokens/brand.yml
aliases:
  name: "accordion"
```

### Component class tokens

Component class tokens are for CSS classes for specific components. Given `carbon-components/src/components/accordion/accordion-classes.yaml`:

```yaml
imports:
  - ./_accordion.yml
namespaces:
  "{!name}"
  "class"
props:
  base: "{!prefix}--{!name}"
  …
  item-active: "{!prefix}--{!name}__item--active"
  …
```

The build toolchain generates `carbon-components/scss/components/accordion/accordion--classes.scss` and `carbon-components/tokens/accordion/accordion--classes.json`, like below:

```scss
$accordion-class-base: "bx--accordion"
…
$accordion-class-item-active: "bx--accordion__item--active"
…
```

```json
{
  "base": "bx--accordion",
  …
  "item-active": "bx--accordion__item--active",
  …
}
```

Such generated `.scss`, as the path indicates, will be included in `carbon-components` NPM package. We also include any files in generated `tokens` directory in `carbon-components` NPM package so that `carbon-components-react` etc. can use those tokens.

### Component selector tokens

Component selector tokens are for CSS selectors for specific components, like:

```yaml
imports:
  - ./_accordion.yml
  - ./accordion--classes.yml
namespaces:
  "{!name}"
  "selector"
props:
  init: "[data-{!name}]"
  item: ".{!item:class}"
  …
```

Component selector tokens are primary for our vanilla codebase, abstracting different DOM structure from different HTML templates for themes. Component selector tokens have very similar directory/naming structure to ones for [component class tokens](#component-class-tokens).

### Component setting tokens

Component setting tokens directly work with our vanilla components, keeping backward-compatibility with Cabron `8.x` codebase, looking like:

```yaml
imports:
  - ./accordion--classes.yml
  - ./accordion--selectors.yml
namespaces:
  - "{!name}"
  - "setting"
props:
  selectorInit: "{!init:selector}"
  selectorAccordionItem: "{!item:selector}"
  …
  classActive: "{!item-active:class}"
```

The build toolchain generates `carbon-components/tokens/components/accordion/accordion--settings.json`, like below:

```json
{
  "selectorInit": "[data-accordion]",
  "selectorAccordionItem": ".bx--accordion__item",
  …
  "classActive": "bx--accordion__item--active"
}
```

## Design token tools

A new toolchain to evaluate design token files and emit design token output will be introduced. The primary interface to the new toolchain is a Gulp plugin, for example:

```javascript
const tokens = require('./tools/tokens');

…

gulp.task('tokens:sass:components', () =>
  gulp
    .src([
      'src/components/**/*-{classes,selectors}.yml',
      '!src/components/**/_*.yml'
    ])
    .pipe(
      tokens
        .plugin({
          format: 'scss',
          flat: true,
        })
        .on('error', gutil.log)
    )
    .pipe(gulp.dest('scss/components'))
);
```

The Gulp plugin takes the following two options:

|Argument|Optional|Description
|--------|--------|-----------
|`format`|No      |The output format. `.scss` and `.json` are the only supported format for now. We'll add other formats as needed.
|`flat`  |Yes     |`true` to ignore the namespaces associated with the design tokens.

# Drawbacks

There are two possible drawbacks with introducing design tokens:

1. The added abstractions make the workflow of implementing design specs less intuitive and more cumbersome
2. The added build steps make the workflow of changing source code and checking the result slower, especially when a developer changes values of design tokens

# Alternatives

A major design alternative would be maintaining separate tokens for different file type, i.e. Sass variables and JSON (or JavaScript module). This approach has much less tooling overhead, though it may be cumbersome for developers to maintain a same token for different file types.

Another major design alternative is aligning the format of design token files to another design token system, e.g. open-source ones, and using the toolchain associated with such format. However, I have found no tool meeting our needs described above, and would end up with lots of hacks if we try to meet the requirements with other design token tools.

Minor design alternatives are:

* Geneting Sass map from global/component tokens, i.e. `color: map-get($carbon-theme, "ui-01")`. While it'd further reduce the risk of naming collision, it'd be a breaking change for project referring to Carbon Sass variables directly. Also, it'd be cumbersome having to use Sass map function just to refer to the theme variables.
* Converting every variable seen in `.scss` to a design token, e.g. `$carbon--ease-in`, `$input-border`, etc. While doing so eliminates "what should be in YAML design tokens?" question, JSON generated from such tokens will be useless.

# Adoption strategy

`carbon-components` changes to introduce design tokens should keep backward-compatibility wherever possible.

One example is global tokens; Global tokens corresponding to existing Sass variables (e.g. `$ui-01`) should produce the same variable name and should be imported from the `.scss` file where the variables used to be, so that existing Sass imports for variables work.

Similar thing should happen to component setting tokens.

Another backward-compaibility layer is suggested for vanilla JavaScript, mentioned [later](#compatibility-layer-for-component-classselector-tokens).

## `carbon-components` NPM package

All generated artifacts from the YAML design tokens should be included in `carbon-components` NPM package so that they can be used for `carbon-components-react`, etc.

## Themes repo

[`carbon-themes`](https://github.com/carbon-design-system/carbon-themes) should introduce the similar toolchain to what this spec suggests, so that the theme artifacts can be generated from YAML design tokens to different formats.

# How we teach this

We'd need some tutorials wrt how to create themes in design tokens YAML files.

# Unresolved questions

Whether we want to maintain design tokens and their associated toolchain in a separate repository/package (from our vanilla repository/package) or in [`carbon-themes`](https://github.com/carbon-design-system/carbon-themes) repo is a good thing to discuss.
